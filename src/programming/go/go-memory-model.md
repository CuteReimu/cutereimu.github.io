---
title: Go语言内存模型
icon: b:golang
order: 11
category: 编程文章
isOriginal: true
tags: 
  - Go
date: 2025-12-16
article: false
---

原文链接：[The Go Memory Model (Version of June 6, 2022)](https://go.dev/ref/mem)

## 引言

Go内存模型规定了在哪些条件下，可以保证一个协程（goroutine）对某个变量的读操作能够观察到另一个协程对该变量写入的值。

### 建议

多个goroutine同时访问并修改数据时，必须将这些访问操作序列化。为了将访问操作序列化，应使用通道操作或其他同步原语（例如[sync](https://go.dev/pkg/sync/)和[sync/atomic](https://go.dev/pkg/sync/atomic/)包中提供的工具）来保护数据。

如果你的程序行为必须通过阅读本文档的其余部分才能理解，那么你是在过度设计。切记不要过度设计。

### 非正式概述

Go语言处理其内存模型的方式与其整体语言设计思路一致，旨在保持语义简单、易懂且实用。本节提供了方法的总览，对于大多数程序员来说已经足够。下一节将对内存模型进行更正式的规范说明。

**数据竞争**的定义是：对某个内存位置的写入操作，与对该相同位置进行的另一个读取或写入操作同时发生（除非所有涉及的访问都是通过`sync/atomic`包提供的原子数据访问）。如前所述，强烈建议程序员使用适当的同步机制来避免数据竞争。在没有数据竞争的情况下，Go程序的行为就像是所有的goroutine都被复用到单个处理器上执行一样。这个特性有时被称为DRF-SC：。

::: note 关于 DRF-SC

Data-race-free programs execute in a sequentially consistent manner.

大致意思是，无数据竞争的程序以顺序一致的方式执行。简写为DRF-SC。

:::

尽管程序员应该编写没有数据竞争的Go程序，但Go实现在应对数据竞争方面存在一些限制。实现可以选择在检测到数据竞争时始终报告该竞争并终止程序。除此之外，对单字长或子字长内存位置的每次读取，都必须观察到实际写入该位置的值（可能来自并发执行的goroutine），且该值尚未被覆盖。这些实现上的约束使得Go更类似于Java或JavaScript，即大多数数据竞争只有有限的结果可能性；而不像C和C++，任何存在数据竞争的程序其意义完全未定义，编译器可能执行任意操作。Go的方法旨在使存在错误的程序更加可靠、易于调试，同时仍然坚持认为数据竞争是错误，并且工具能够诊断和报告它们。

## 内存模型

Go内存模型的以下正式定义，紧密遵循Hans-J. Boehm和Sarita V. Adve在PLDI 2008上发表的论文《C++并发内存模型的基础》中提出的方法。无数据竞争程序的定义以及对无竞争程序顺序一致性的保证，均与该工作中的定义等效。

内存模型描述了程序执行（由goroutine执行组成，而goroutine执行又由内存操作组成）所需满足的要求。

**内存操作**通过四个细节来建模：

- 其**类型**，表明它是普通数据读取、普通数据写入，还是同步操作（例如原子数据访问、互斥锁操作或通道操作），
- 其在程序中的**位置**，
- 所访问的**内存位置或变量**，
- 以及该操作**读取或写入的数值**。

某些内存操作是**类读取操作**，包括读取、原子读取、互斥锁加锁和通道接收。其他内存操作是**类写入操作**，包括写入、原子写入、互斥锁解锁、通道发送和通道关闭。还有一些操作，例如原子比较并交换，同时属于类读取和类写入操作。

一个**goroutine执行**被建模为由单个goroutine执行的一组内存操作。

**要求1**：对于每个goroutine，考虑到从内存读取和向内存写入的数值，其内存操作必须对应于该goroutine的正确顺序执行。该执行必须符合"先后顺序"关系，该关系由Go语言规范为Go的控制流结构以及表达式求值顺序所定义的偏序要求决定。

一个Go**程序执行**被建模为一组goroutine执行，连同映射W，该映射指明了每个类读取操作所读取的类写入操作。（同一程序的不同执行可能有不同的程序执行过程）。

**要求2**：对于给定的程序执行，当映射 $W$ 仅限于同步操作时，必须能够通过某种与执行顺序及这些操作读写数值相一致的同步操作隐式全序来解释。

"同步于"关系是同步内存操作上的一个偏序，由 $W$ 推导得出。如果一个同步的类读取内存操作 $r$ 观察到一个同步的类写入内存操作 $w$（即 $W(r) = w$），那么 $w$ 同步于 $r$。非正式地说，"同步于"关系是前一段提到的隐含全序的一个子集，仅限于 $W$ 直接观察到的信息。

"发生于"关系定义为"先后顺序"关系和"同步于"关系之并集的传递闭包。

**要求3**：对于内存位置 $x$ 上的一个普通（非同步）数据读取操作 $r$，$W(r)$ 必须是一个对 $r$ **可见**的写入操作 $w$，这里"可见"意味着以下两者同时成立：

1.  $w$ 发生于 $r$。
2.  不存在其他对 $x$ 的写入操作 $w'$ 使得 $w'$ 发生于 $r$ 并且 $w$ 发生于 $w'$。

内存位置 $x$ 上的一个**读写数据竞争**由一个对 $x$ 的类读取内存操作 $r$ 和一个对 $x$ 的类写入内存操作 $w$ 构成，其中至少有一个是非同步操作，并且它们未被"发生于"关系排序（即 $r$ 不发生于 $w$ 且 $w$ 不发生于 $r$）。

内存位置 $x$ 上的一个**写写数据竞争**由两个对 $x$ 的类写入内存操作 $w$ 和 $w'$ 构成，其中至少有一个是非同步操作，并且它们未被"发生于"关系排序。

注意，如果内存位置 $x$ 上没有读写或写写数据竞争，那么任何对 $x$ 的读取操作 $r$ 都只有一个可能的 $W(r)$：在"发生于"顺序中紧邻其前的那个单一的写入操作 $w$。

更一般地，可以证明，任何数据竞争无关（即其程序执行中没有读写或写写数据竞争）的Go程序，其所有可能的结果都只能由goroutine执行的某种顺序一致的交错执行来解释。（证明过程与上文引用的Boehm和Adve论文中的第7节相同。）此特性被称为DRF-SC。

此正式定义的目的是与包括C、C++、Java、JavaScript、Rust和Swift在内的其他语言为无竞争程序提供的DRF-SC保证相匹配。

某些Go语言操作，例如goroutine创建和内存分配，充当同步操作。这些操作对"同步于"偏序关系的影响记录在下文的"同步"章节中。各个包应为其自身的操作提供类似的文档说明。